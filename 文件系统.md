# 文件系统

1. 脚本路径操作
2. C++路径操作
3. windows下dll路径问题

---

## 脚本类:

**常用的遍历获取文件大小**

* **os.listdir(path)** 　　　　　 返回指定目录下的所有文件和目录名
* **os.path.getsize(name)** 　　 获得文件大小，如果name是目录返回0
* **os.path.isfile()** 和 **os.path.isdir()**    判断是否为文件
* **os.path.dirname(path)**　　　 截取最后一个文件分隔符/or,需谨慎


    #python 遍历目录
    for i  in os.listdir(path):
        print (i)


* **shutil.rmtree(path[, ignore_errors[, onerror])**
* **shutil.copyfile(src, dst)**
* **shutil.move(src, dst)**
* **shutil.copytree(olddir,newdir** [,True/Flase符号链接是否还是连接否则是副本])


*使用相对低频目录的创建删除切换*

* **os.remove(path)** 　　　　　 函数用来删除一个文件
* **os.rmdir('dirname')** 　　　　    建议替换 shutil.rmtree
* **os.mkdir("newdir")**     　　  　　 建议替换os.makedirs
* **os.makedirs(path)**
* **os.rename(current_file_name, new_file_name)**
* **os.chdir("newdir")**
* **os.getcwd()**
* **os.walk(path)**　　　　　　　 在取当前下的子目录和文件分类时比较有用


    for i in os.walk(r'F:topdir'):
       print (i)

    ('F:topdir', ['chdir1', 'chdir2'], ['level.txt'])
    ('F:topdirchdir1', [], ['leve2.txt'])
    ('F:topdirchdir2', [], [])


---
## C++

enum file_type { status_error, file_not_found, regular_file, directory_file,
                       symlink_file, block_file, character_file, fifo_file, socket_file,
                       type_unknown
                     };
namespace boost::filesystem

* **void         copy(const path& from, const path& to[, system::error_code& ec])**   //函数都有两种重载异常和错误码
* **bool         create_directories(const path& p);                              **      //windows下有bug,正确返回时未必系统准备就绪
* **void         copy_file(const path& from, const path& to);                    **  	//需要先建立文件夹
* **bool         exists(const path& p)                                           **
* **uintmax_t    file_size(const path& p)                                        **
* **bool         is_directory(file_status s)                                     **
* **bool         is_empty(const path& p)                                         **
* **bool         is_regular_file(file_status s)                                  **
* **bool         is_symlink(const path& p)                                       **
* **std::time_t  last_write_time(const path& p)                                  **
* **bool         remove(const path& p)                                           **
* **uintmax_t    remove_all(const path& p)                                       **
* **path& remove_filename()			                       						**		//效率上有优势 much more efficient than *this = parent_path()
* ** void copy_directory(const path& from, const path& to); 					**			// 不建议使用

**不常用                                                                       **
* **void swap(path& lhs, path& rhs)			                  					**			//交换文件内容
* **void         create_symlink(const path& to, const path& new_symlink);        **
* **void         create_hard_link(const path& to, const path& new_hard_link)     **
* **uintmax_t    hard_link_count(const path& p)                                  **
* **void         resize_file(const path& p, uintmax_t size)                      **
* **file_status  status(const path& p)                                           **
* **path         temp_directory_path()                                  		**		//环境变量决定

>遍历目录 模仿python

    for(boost::filesystem::recursive_directory_iterator end, dir("./); dir != end; ++dir){
      cout << *dir << endl;
    }


**路径名: **
* **class  boost::filesystem::path                                               **

* **template &lt;class String&gt;                                                **
* **String string(const codecvt_type& cvt=codecvt()) const;  					**			// native format
* **const wstring       wstring(const codecvt_type& cvt=codecvt()) const         **
* **const u16string     u16string() const;                                       **
* **const u32string     u32string() const                                        **
* **const value_type*   c_str() const;   // native().c_str()                     **

**路径操作:                                                                    **

* **path  parent_path() const                                                    **
* **path  filename() const;                                                      **
* **path  stem() const;                                                          **
* **path  extension() const                                                      **
* **bool empty() const                                                           **

---

## windows 获取dll路径通用函数
>windows提供了获取exe路径的函数,能满足大部分获取可执行程序的需求,但当显示加载,或者跨语言调用时
可执行程序未必和动态库在同一位置

在知道明确句柄的情况下可以使用
GetMuleFileName

>在不知道句柄是该如何处理呢

此外推荐另外一种方式,根据字符常量地址获取dll路径
**VirtualQuery**和__VirtualQueryEx__

    HMODULE getDllModule(LPCVOID pcaller)
    {
      HMODULE  hmdl = null;
      MEMORY_BASIC_INFORMATION  mbi;
      if(VirtualQuery(pcaller, &mbi, sizeof(MEMORY_BASIC_INFORMATION)) ==  sizeof(MEMORY_BASIC_INFORMATION)  ){
        hmdl = (HMODULE)mbi.AllocationBase;
      }
      return hmdl;
    }

如果要获取dll名字(路径)

    CString getDllModuleName(LPCVOID pcaller){
      HMODULE hmdl = getDllModule(pcaller);
      if(!hmdl) return "";
      const int max_size = 512;
      TCHAR tzPath[max_size] = {0};
      ::GetModuleFileName(hmdl, tzPath, max_size);

      return tzPath;
    }


另外一种方式:

    CString getDllAddress(){  
        HMODULE handle = NULL;  
        BOOL bret = GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,  
            _T("thismodule"),   //该dll上任意地址，这里取个字符常量或者弄个本地函数地址;  
            &handle  
            );  
        if (!bret) return _T("");  
    
        TCHAR  szBuffer[MAX_PATH] = { 0 };  
        GetModuleFileName(handle, szBuffer, sizeof(szBuffer));  
        return szBuffer;  
    }  
