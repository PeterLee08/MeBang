
# File Operation:
-----
## python
>实际使用python处理文本问题非常简单,但是觉得相对其他语言优势不明显,但是和pandas挂钩时问题就完全不一样了.先只说pandas

    with open('file') as f:
     for i in f.readlines():
        print(i)


**方法 描述**

* **f.close()**           关闭文件，记住用open()打开文件后一定要记得关闭它，否则会占用系统的可打开文件句柄数。
* **f.fileno()**           获得文件描述符，是一个数字
* **f.flush()**           刷新输出缓存
* **f.isatty()**           如果文件是一个交互终端，则返回True，否则返回False。
* **f.read([count])**        读出文件，如果有count，则读出count个字节。
* **f.readline()**         读出一行信息。
* **f.readlines()**         读出所有行，也就是读出整个文件的信息。
* **f.seek(offset[,where])**    把文件指针移动到相对于where的offset位置
* **f.tell()**              获得文件指针位置。
* **f.truncate([size])**        截取文件，使文件的大小为size。
* **f.write(string)**         把string字符串写入文件。
* **f.writelines(list)**         把list中的字符串一行一行地写入文件，是连续写入文件，没有换行。



# C++

>最有意思的主要将全局变量cout 将cout的buff绑定到指定到不同文件可以在不同模块间输出自己的信息,很多事情可以不用去关心. 使用 **cout.rdbuf(ofs.rdbuf())** 之后在不同动态库不同模块间你想输出的信息就不在愁,如何改变代码结构传递句柄,如何多个句柄输出到一个文件的问题: 因为cout是全局的哈

空白符制表符等分割数据一次读取,可迭代数据一次写入

	std::ifstream ifs("d:/text.txt");
	list<int> data(istream_iterator<int>{ifs}, istream_iterator<int>());

    std::ofstream ofs("d:/text1.txt");
    std::copy(begin(data), end(data), ostream_iterator<int>{ofs,"delimeter"});


    std::ifstream t("file.txt");

    //一次读入string 
      //包括空白符 
    std::string str((std::istreambuf_iterator<char>(t)), std::istreambuf_iterator<char>()); 
      //跳过空白符
    string fileData((istream_iterator<char>(inputFile)), istream_iterator<char>());
    //一次读入缓冲区
    char buf[1024] = { 0 };
	ifs.read(buf, 1024);
    //一次直接写出
    std::ofstream ofs("d:/text1.txt");  
    ofs << t.rdbuf();  
    
